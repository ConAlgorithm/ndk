# JNI
### JNI(Java Native Interface)JAVA原生接口

#### 使用JNI可以使Java代码和其他语言写的代码(如C/C++代码)进行交互。
#### 问：为什么要进行交互?
* 首先，Java语言提供的类库无法满足要求,且在数学运算,实时渲染的游戏上,音视频处理等方面上与C/C++相比效率稍低。
* 然后，Java语言无法直接操作硬件，C/C++代码不仅能操作硬件而且还能发挥硬件最佳性能。
* 接着，使用Java调用本地的C/C++代码所写的库，省去了重复开发的麻烦，并且可以利用很多开源的库提高程序效率。

### C语言常见术语：
#### 库函数：
>为了代码重用，在C语言中提供了一些常用的、用于执行一些标准任务(如输入/出)的函数，这些函数事先被编译，并生成目标代码，然后将生成的目标代码打包成一个库文件，以供再次使用。 库文件中的函数被称为库函数，库文件被称为函数库。<br>
>在Windows中C语言库函数中的中间代码都是以.obj为后缀的，Linux中是以 .o为后缀。<br>
>提示：单个目标代码是无法直接执行的，目标代码在运行之前需要使用连接程序将目标代码和其他库函数连接在一起后生成可执行的文件。 Windows下.dll的文件 , linux下 .so .a的文件.<br>

#### 头文件：xxx.h
>头文件中存放的是对某个库中所定义的函数、宏、类型、全局变量等进行声明，它类似于一份仓库清单。若用户程序中需要使用某个库中的函数，则只需要将该库所对应的头文件include到程序中即可。<br>
>头文件中定义的是库中所有函数的函数原型。而函数的具体实现则是在库文件中。<br>
>简单的说：头文件是给编译器用的，库文件是给连接器用的。<br>
>在链接器连接程序时，会依据用户程序中导入的头文件，将对应的库函数导入到程序中。头文件以.h为后缀名。<br>

#### 函数库：
>动态库：在编译用户程序时不会将用户程序内使用的库函数连接到用户程序的目标代码中，只有在运行时，且用户程序执行到相关函数时才会调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。<br>
>静态库：在编译用户程序时会将其内使用的库函数连接到目标代码中，程序运行时不再需要静态库。使用静态库生成可执行文件比较大。<br>
>在Linux中：<br>
>>静态库命名一般为：lib+库名+.a 。<br>
>>如：libcxy.a 其中lib说明此文件是一个库文件，cxy是库的名称，.a说明是静态的。<br>
>>动态库命名一般为：lib+库名+.so 。.so说明是动态的。<br>

#### 交叉编译：
>将中间代码连接成当前计算机可执行的二进制程序时，连接程序会根据当前计算机的CPU、操作系统的类型来转换。<br>
>根据运行的设备的不同，可以将cpu分为：<br>
* arm结构 ：主要在移动手持、嵌入式设备上。<br>
* x86结构 ： 主要在台式机、笔记本上使用。如Intel和AMD的CPU 。<br>
>若想在使用了基于x86结构CPU的操作系统中编译出可以在基于arm结构CPU的操作系统上运行的代码，就必须使用交叉编译。<br>
>交叉编译：在一个平台下编译出在另一个平台中可以执行的二进制代码。Google提供的NDK就可以完成交叉编译的工作。<br>

#### NDK全称：Native Development Kit 。
>NDK是一系列工具的集合，它有很多作用。<br>
>首先，NDK可以帮助开发者快速开发C(或C++)的动态库。<br>
>其次，NDK集成了交叉编译器。使用NDK，我们可以将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。<br>
>NDK工具必须在Linux下运行，它可以在linux环境下编译出可以在arm平台下运行的二进制库文件。<br>

>使用JNI技术，其实就是在Java程序中，调用C语言的函数库中提供的函数，来完成一些Java语言无法完成的任务。由于Java语言和C语言结构完全不相同，因此若想让它们二者交互，则需要制定一系列的规范。JNI就是这组规范，此时Java只和JNI交互，而由JNI去和C语言交互。<br>
>JNI技术分为两部分：Java端和C语言端。且以Java端为主导。<br>
* 首先，Java程序员在Java端定义一些native方法，并将这些方法以C语言头文件的方式提供给C程序员。<br>
* 然后，C程序员使用C语言，来实现Java程序员提供的头文件中定义的函数。<br>
* 接着，C程序员将函数打包成一个库文件，并将库文件交给Java程序员。<br>
* 最后，Java程序员在Java程序中导入库文件，然后调用native方法。<br>

>在Java程序执行的时候，若在某个类中调用了native方法，则虚拟机会通过JNI来转调用库文件中的C语言代码。<br>
>提示：C代码最终是在Linux进程中执行的，而不是在虚拟机中。<br>

### JAVA平台和系统环境（Host Environment）
>系统环境代指本地操作系统环境，它有自己的本地库和CPU指令集。本地程序（Native Applications）使用C/C++这样的本地语言来编写，被编译成只能在本地系统环境下运行的二进制代码，并和本地库链接在一起。本地程序和本地库一般地会依赖于一个特定的本地系统环境。比如，一个系统下编译出来的C程序不能在另一个系统中运行。<br>

### JNI扮演的角色
>JNI的强大特性使我们在使用JAVA平台的同时，还可以重用原来的本地代码。作为虚拟机实现的一部分，JNI允许JAVA和本地代码间的双向交互。<br>
>JNI可以这样与本地程序进行交互：<br>
>1、你可以使用JNI来实现“本地方法”（native methods），并在JAVA程序中调用它们。<br>
>2、JNI支持一个“调用接口”（invocation interface），它允许你把一个JVM嵌入到本地程序中。本地程序可以链接一个实现了JVM的本地库，然后使用“调用接口”执行JAVA语言编写的软件模块。例如，一个用C语言写的浏览器可以在一个嵌入式JVM上面执行从网上下载下来的applets。<br>

### JNI的副作用
>请记住，一旦使用JNI，JAVA程序就丧失了JAVA平台的两个优点：<br>
>1、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。<br>
>2、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。<br>
>一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了JAVA和C之间的耦合性。<br>

### 什么场合下应该使用JNI
>当你开始着手准备一个使用JNI的项目时，请确认是否还有替代方案。像上一节所提到的，应用程序使用JNI会带来一些副作用。下面给出几个方案，可以避免使用JNI的时候，达到与本地代码进行交互的效果：<br>
>1、JAVA程序和本地程序使用TCP/IP或者IPC进行交互。<br>
>2、当用JAVA程序连接本地数据库时，使用JDBC提供的API。<br>
>3、JAVA程序可以使用分布式对象技术，如JAVA IDL API。<br>
>这些方案的共同点是，JAVA和C 处于不同的线程，或者不同的机器上。这样，当本地程序崩溃时，不会影响到JAVA程序。<br>
>下面这些场合中，同一进程内JNI的使用无法避免：<br>
>1、程序当中用到了JAVA  API不提供的特殊系统环境才会有的特征。而跨进程操作又不现实。<br>
>2、你可能想访问一些己有的本地库，但又不想付出跨进程调用时的代价，如效率，内存，数据传递方面。<br>
>3、JAVA程序当中的一部分代码对效率要求非常高，如算法计算，图形渲染等。<br>
>总之，只有当你必须在同一进程中调用本地代码时，再使用JNI。<br>

